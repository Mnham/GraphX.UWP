using GraphX.Common;
using GraphX.Common.Enums;
using GraphX.Common.Exceptions;
using GraphX.Common.Interfaces;
using GraphX.Common.Models;
using GraphX.Controls.Models;

using QuikGraph;

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

using Windows.UI.Xaml;
using Windows.UI.Xaml.Media.Animation;

using Point = Windows.Foundation.Point;
using Rect = GraphX.Measure.Rect;
using Size = GraphX.Measure.Size;
using USize = Windows.Foundation.Size;

namespace GraphX.Controls
{
    public class GraphArea<TVertex, TEdge, TGraph> : GraphAreaBase, IDisposable
        where TVertex : class, IGraphXVertex
        where TEdge : class, IGraphXEdge<TVertex>
        where TGraph : class, IMutableBidirectionalGraph<TVertex, TEdge>
    {
        public static readonly DependencyProperty LogicCoreProperty = DependencyProperty.Register(
                    nameof(LogicCore),
                    typeof(IGXLogicCore<TVertex, TEdge, TGraph>),
                    typeof(GraphArea<TVertex, TEdge, TGraph>),
                    new PropertyMetadata(null, Logic_core_changed));

        protected readonly HashSet<long> DataIdsCollection = new();

        protected readonly HashSet<long> EdgeDataIdsCollection = new();

        private readonly Dictionary<TEdge, EdgeControl> _edgeslist = new();

        private readonly Dictionary<TVertex, VertexControl> _vertexlist = new();

        private int _dataIdCounter = 1;

        private int _edgeDataIdCounter = 1;

        private bool? _edgesDragEnabled;

        private CancellationTokenSource _layoutCancellationSource;

        private Task _layoutTask;

        private CancellationTokenSource _linkedLayoutCancellationSource;

        private StateStorage<TVertex, TEdge, TGraph> _stateStorage;

        private EdgeDashStyle? _svEdgeDashStyle;

        private bool? _svEdgeHlEnabled;

        private GraphControlType? _svEdgeHlObjectType;

        private bool? _svShowEdgeArrows;

        private bool? _svUpdateLabelPosition;

        private EdgesType? _svVertexHlEdgesType;

        private bool? _svVertexHlEnabled;

        private GraphControlType? _svVertexHlObjectType;

        private bool? _svVertexLabelShow;

        private VertexShape? _svVertexShape;

        private bool? _svVerticesDragEnabled;

        private bool? _svVerticesDragUpdateEdges;

        /// <summary>
        /// Gets or sets control factory class that allows you to define what vertex and edge controls will be generated by GraphX
        /// </summary>
        public IGraphControlFactory ControlFactory { get; set; }

        /// <summary>
        /// Gets or sets in which order GraphX controls are drawn
        /// </summary>
        public ControlDrawOrder ControlsDrawOrder { get; set; }

        /// <summary>
        /// Link to LogicCore. Gets if edge curving is used.
        /// </summary>
        internal override bool EdgeCurvingEnabled => LogicCore != null && LogicCore.EdgeCurvingEnabled;

        /// <summary>
        /// Link to LogicCore. Gets edge curving tolerance.
        /// </summary>
        internal override double EdgeCurvingTolerance => LogicCore?.EdgeCurvingTolerance ?? 0;

        /// <summary>
        /// Gets or sets edge label control factory. Edge labels will be generated at the end of the graph generation process.
        /// </summary>
        public ILabelFactory<UIElement> EdgeLabelFactory { get; set; }

        /// <summary>
        /// Gets edge controls read only collection. To modify collection use AddEdge() RemoveEdge() methods.
        /// </summary>
        public IDictionary<TEdge, EdgeControl> EdgesList => _edgeslist;

        /// <summary>
        /// Link to LogicCore. Gets if parallel edges are enabled.
        /// </summary>
        internal override bool EnableParallelEdges => LogicCore != null && LogicCore.EnableParallelEdges;

        /// <summary>
        /// Gets or sets if visual properties such as edge dash style or vertex shape should be automaticaly applied to newly added visuals which are added using AddVertex() or AddEdge() or similar methods.
        /// True by default.
        /// </summary>
        public bool EnableVisualPropsApply { get; set; }

        /// <summary>
        /// Gets or sets if visual properties such as edge dash style or vertex shape should be automaticaly reapplied to visuals when graph is regenerated.
        /// True by default.
        /// </summary>
        public bool EnableVisualPropsRecovery { get; set; }

        /// <summary>
        /// Gets or sets if visual graph should be updated if graph is filtered.
        /// Remove all visuals with no keys in data graph and add all visuals that has keys in data graph.
        /// Default value is True.
        /// </summary>
        public bool EnableVisualsRenewOnFiltering { get; set; } = true;

        /// <summary>
        /// Gets if object has been disposed and can't be used anymore
        /// </summary>
        public bool IsDisposed { get; private set; }

        /// <summary>
        /// Link to LogicCore. Gets if edge routing is used.
        /// </summary>
        internal override bool IsEdgeRoutingEnabled => LogicCore != null && LogicCore.IsEdgeRoutingEnabled;

        /// <summary>
        /// Gets or sets GraphX logic core object that will drive this visual
        /// </summary>
        public IGXLogicCore<TVertex, TEdge, TGraph> LogicCore
        {
            get => (IGXLogicCore<TVertex, TEdge, TGraph>)GetValue(LogicCoreProperty);
            set => SetValue(LogicCoreProperty, value);
        }

        /// <summary>
        /// Provides methods for saving and loading graph layout states
        /// </summary>
        public StateStorage<TVertex, TEdge, TGraph> StateStorage
        {
            get
            {
                if (_stateStorage == null && !IsDisposed)
                {
                    CreateNewStateStorage();
                }

                return _stateStorage;
            }
            private set => _stateStorage = value;
        }

        /// <summary>
        /// Gets or sets vertex label control factory. Vertex labels will be generated at the end of the graph generation process.
        /// </summary>
        public ILabelFactory<UIElement> VertexLabelFactory { get; set; }

        /// <summary>
        /// Gets vertex controls read only collection. To modify collection use AddVertex() RemoveVertex() methods.
        /// </summary>
        public IDictionary<TVertex, VertexControl> VertexList => _vertexlist;

        public GraphArea()
        {
            EnableVisualPropsRecovery = true;
            EnableVisualPropsApply = true;
            EdgeLabelFactory = new DefaultEdgelabelFactory();
            //VertexLabelFactory = new DefaultLabelFactory<AttachableVertexLabelControl, IVertexLabelControl>();

            Transitions = new TransitionCollection { new ContentThemeTransition() };
            ControlFactory = new GraphControlFactory(this);
        }

        /// <summary>
        /// Add custom control for
        /// </summary>
        /// <param name="control"></param>
        public virtual void AddCustomChildControl(UIElement control)
        {
            if (!Children.Contains(control))
            {
                Children.Add(control);
            }
            SetX(control, 0);
            SetY(control, 0);
        }

        /// <summary>
        /// Add an edge to layout. Edge is added into the end of the visual tree causing it to be rendered above all vertices.
        /// </summary>
        /// <param name="edgeData">Edge data object</param>
        /// <param name="edgeControl">Edge visual control</param>
        /// <param name="generateLabel">Generate edge label for this control using EdgeLabelFactory</param>
        public void AddEdge(TEdge edgeData, EdgeControl edgeControl, bool generateLabel = false)
        {
            if (AutoAssignMissingDataId && edgeData.ID == -1)
            {
                edgeData.ID = GetNextUniqueId(false);
            }

            InternalAddEdge(edgeData, edgeControl);
            if (EnableVisualPropsApply && edgeControl != null)
            {
                ReapplySingleEdgeVisualProperties(edgeControl);
            }

            if (generateLabel && EdgeLabelFactory != null)
            {
                GenerateEdgeLabel(edgeControl);
            }
        }

        /// <summary>
        /// Usability extension method.
        /// Add data edge to graph and edge to layout. LogicCore::Graph should be assigned or exception will be thrown.
        /// </summary>
        /// <param name="edgeData">Edge data object</param>
        /// <param name="edgeControl">Edge visual control</param>
        /// <param name="generateLabel">Generate edge label for this control using EdgeLabelFactory</param>
        public void AddEdgeAndData(TEdge edgeData, EdgeControl edgeControl, bool generateLabel = false)
        {
            if (LogicCore?.Graph == null)
            {
                throw new GX_InvalidDataException("LogicCore or its graph hasn't been assigned. Can't add data edge!");
            }

            LogicCore.Graph.AddEdge(edgeData);
            AddEdge(edgeData, edgeControl, generateLabel);
        }

        /// <summary>
        /// Add vertex to layout
        /// </summary>
        /// <param name="vertexData">Vertex data object</param>
        /// <param name="vertexControl">Vertex visual control object</param>
        /// <param name="generateLabel">Generate vertex label for this control using VertexLabelFactory</param>
        public void AddVertex(TVertex vertexData, VertexControl vertexControl, bool generateLabel = false)
        {
            if (AutoAssignMissingDataId && vertexData.ID == -1)
            {
                vertexData.ID = GetNextUniqueId(true);
            }

            InternalAddVertex(vertexData, vertexControl);
            if (EnableVisualPropsApply && vertexControl != null)
            {
                ReapplySingleVertexVisualProperties(vertexControl);
            }

            if (generateLabel && VertexLabelFactory != null)
            {
                GenerateVertexLabel(vertexControl);
            }

            bool hasStorage = LogicCore?.AlgorithmStorage != null && vertexData.SkipProcessing != ProcessingOptionEnum.Exclude;
            if (hasStorage)
            {
                Measure.Point pos = vertexControl.GetPositionGraphX(true);
                LogicCore.AlgorithmStorage.AddSingleVertex(vertexData, pos, new Rect(pos, new Size(vertexControl.ActualWidth, vertexControl.ActualHeight)));
            }
        }

        /// <summary>
        /// Usability extension method.
        /// Add data vertex to graph and vertex control to layout. LogicCore::Graph should be assigned or exception will be thrown.
        /// </summary>
        /// <param name="vertexData">Vertex data object</param>
        /// <param name="vertexControl">Vertex visual control object</param>
        /// <param name="generateLabel">Generate vertex label for this control using VertexLabelFactory</param>
        public void AddVertexAndData(TVertex vertexData, VertexControl vertexControl, bool generateLabel = false)
        {
            if (LogicCore?.Graph == null)
            {
                throw new GX_InvalidDataException("LogicCore or its graph hasn't been assigned. Can't add data vertex!");
            }

            LogicCore.Graph.AddVertex(vertexData);
            AddVertex(vertexData, vertexControl, generateLabel);
        }

        //private bool? _svAlignEdgeLabels;
        /// <summary>
        /// Aligns all labels with edges or displays them horizontaly
        /// </summary>
        /// <param name="isEnabled">Boolean value</param>
        public void AlignAllEdgesLabels(bool isEnabled = true)
        {
            //_svAlignEdgeLabels = isEnabled;
            foreach (EdgeControl item in _edgeslist.Values)
            {
                foreach (IEdgeLabelControl l in item.EdgeLabelControls)
                {
                    l.AlignToEdge = isEnabled;
                }
            }
        }

        public void AutoresolveEntitiesId()
        {
            AutoresolveIds(true);
        }

        public async Task CancelRelayoutAsync()
        {
            if (_layoutTask == null)
            {
                return;
            }

            _layoutCancellationSource.Cancel();

            try
            {
                // Wait, but don't block the dispatcher, because the background task might be trying to execute on the UI thread.
                await _layoutTask;
            }
            catch (OperationCanceledException)
            {
                // This is expected if the task was indeed canceled
            }

            _layoutCancellationSource.Dispose();
            _layoutCancellationSource = null;
            _layoutTask = null;

            if (_linkedLayoutCancellationSource != null)
            {
                _linkedLayoutCancellationSource.Dispose();
                _linkedLayoutCancellationSource = null;
            }
        }

        /// <summary>
        /// Clear graph visual layout (all edges, vertices and their states storage if any) and (optionally) LogicCore
        /// </summary>
        /// <param name="removeCustomObjects">Also remove any possible custom objects</param>
        /// <param name="clearStates">Also clear states storage (if you select clearLogicCore it will be cleaned anyway)</param>
        /// <param name="clearLogicCore">Also clear LogiCore data</param>
        public virtual void ClearLayout(bool removeCustomObjects = true, bool clearStates = false, bool clearLogicCore = false)
        {
            RemoveAllEdges();
            RemoveAllVertices();
            if (removeCustomObjects)
            {
                Children.Clear();
            }

            CreateNewStateStorage();

            if (clearLogicCore)
            {
                LogicCore?.Clear();
            }

            if (clearLogicCore || clearStates)
            {
                _stateStorage?.Dispose();
            }
        }

        public void Dispose()
        {
            IsDisposed = true;
            if (_stateStorage != null)
            {
                _stateStorage.Dispose();
                _stateStorage = null;
            }
            if (LogicCore != null)
            {
                LogicCore.Dispose();
                LogicCore = null;
            }
            MoveAnimation = null;
            DeleteAnimation = null;
            MouseOverAnimation = null;
            OnDispose();
        }

        public virtual void ExportAsImage(string filename, ImageType itype, bool useZoomControlSurface = false, double dpi = PrintHelper.DEFAULT_DPI, int quality = 100)
        {
            PrintHelper.ExportToImage(this, new Uri(filename, UriKind.Absolute), itype, useZoomControlSurface, dpi, quality);
        }

        /// <summary>
        /// Export current graph layout into the chosen image file and format. layout will be saved in full size.
        /// </summary>
        /// <param name="itype">Image format</param>
        /// <param name="dpi">Optional image DPI parameter</param>
        /// <param name="useZoomControlSurface">Use zoom control parent surface to render bitmap (only visible zoom content will be exported)</param>
        /// <param name="quality">Optional image quality parameter (for JPEG)</param>
        public virtual void ExportAsImageDialog(ImageType itype, bool useZoomControlSurface = false, double dpi = PrintHelper.DEFAULT_DPI, int quality = 100)
        {
        }

        /// <summary>
        /// Export current graph layout into the JPEG image file. layout will be saved in full size.
        /// </summary>
        /// <param name="quality">Optional image quality parameter</param>
        public virtual void ExportAsJpeg(int quality = 100)
        {
            ExportAsImageDialog(ImageType.JPEG, true, PrintHelper.DEFAULT_DPI, quality);
        }

        /// <summary>
        /// Export current graph layout into the PNG image file. layout will be saved in full size.
        /// </summary>
        public virtual void ExportAsPng()
        {
            ExportAsImageDialog(ImageType.PNG);
        }

        /// <summary>
        /// Obtain graph layout data, which can then be used with a serializer.
        /// </summary>
        /// <exception cref="GX_InvalidDataException">Occurs when LogicCore or object Id isn't set</exception>
        public virtual List<GraphSerializationData> ExtractSerializationData()
        {
            if (LogicCore == null)
            {
                throw new GX_InvalidDataException("LogicCore -> Not initialized!");
            }

            if (AutoAssignMissingDataId)
            {
                AutoresolveIds(true);
            }

            List<GraphSerializationData> dlist = new();
            foreach (KeyValuePair<TVertex, VertexControl> item in VertexList) //ALWAYS serialize vertices first
            {
                dlist.Add(new GraphSerializationData { Position = item.Value.GetPositionGraphX(), Data = item.Key, IsVisible = item.Value.Visibility == Visibility.Visible, HasLabel = item.Value.VertexLabelControl != null });
                if (item.Key.ID == -1)
                {
                    throw new GX_InvalidDataException("ExtractSerializationData() -> All vertex datas must have positive unique ID!");
                }
            }
            foreach (KeyValuePair<TEdge, EdgeControl> item in EdgesList)
            {
                // item.Key.RoutingPoints = new Point[] { new Point(0, 123), new Point(12, 12), new Point(10, 234.5) };
                dlist.Add(new GraphSerializationData { Position = new Measure.Point(), Data = item.Key, IsVisible = item.Value.Visibility == Visibility.Visible, HasLabel = item.Value.EdgeLabelControls.Count > 0 });
                if (item.Key.ID == -1)
                {
                    throw new GX_InvalidDataException("ExtractSerializationData() -> All edge datas must have positive unique ID!");
                }
            }
            return dlist;
        }

        /// <summary>
        /// Generates all possible valid edges for Graph vertexes
        /// </summary>
        /// <param name="defaultVisibility">Default edge visibility on layout</param>
        /// <param name="updateLayout">Ensures that layout is properly updated before edges calculation. If you are sure that it is already updated you can set this param to False to increase performance. </param>
        public virtual void GenerateAllEdges(Visibility defaultVisibility = Visibility.Visible, bool updateLayout = true)
        {
            if (updateLayout)
            {
                UpdateLayout();
            }
            GenerateAllEdgesInternal(defaultVisibility);
        }

        /// <summary>
        /// Generates and displays edges for specified vertex
        /// </summary>
        /// <param name="vc">Vertex control</param>
        /// <param name="edgeType">Type of edges to display</param>
        /// <param name="defaultVisibility">Default edge visibility on layout</param>
        public override void GenerateEdgesForVertex(VertexControl vc, EdgesType edgeType, Visibility defaultVisibility = Visibility.Visible)
        {
            if (LogicCore == null)
            {
                throw new GX_InvalidDataException("LogicCore -> Not initialized!");
            }

            RemoveAllEdges();

            TEdge[] inlist = null;
            TEdge[] outlist = null;
            switch (edgeType)
            {
                case EdgesType.Out:
                    outlist = LogicCore.Graph.OutEdges(vc.Vertex as TVertex).ToArray();
                    break;

                case EdgesType.In:
                    inlist = LogicCore.Graph.InEdges(vc.Vertex as TVertex).ToArray();
                    break;

                default:
                    outlist = LogicCore.Graph.OutEdges(vc.Vertex as TVertex).ToArray();
                    inlist = LogicCore.Graph.InEdges(vc.Vertex as TVertex).ToArray();
                    break;
            }

            bool gotSelfLoop = false;
            if (inlist != null)
            {
                foreach (TEdge item in inlist)
                {
                    if (gotSelfLoop)
                    {
                        continue;
                    }

                    EdgeControl ctrl = ControlFactory.CreateEdgeControl(
                        _vertexlist[item.Source],
                        vc,
                        item,
                        _svShowEdgeArrows ?? true,
                        defaultVisibility);

                    InsertEdge(item, ctrl);
                    ctrl.PrepareEdgePath();
                    if (item.Source == item.Target)
                    {
                        gotSelfLoop = true;
                    }
                }
            }

            if (outlist != null)
            {
                foreach (TEdge item in outlist)
                {
                    if (gotSelfLoop)
                    {
                        continue;
                    }

                    EdgeControl ctrl = ControlFactory.CreateEdgeControl(
                        vc,
                        _vertexlist[item.Target],
                        item,
                        _svShowEdgeArrows ?? true,
                        defaultVisibility);

                    InsertEdge(item, ctrl);
                    ctrl.PrepareEdgePath();
                    if (item.Source == item.Target)
                    {
                        gotSelfLoop = true;
                    }
                }
            }
        }

        /// <summary>
        /// Cancel all undergoing async calculations
        /// </summary>
        /// <summary>
        /// Generate visual graph asynchronously
        /// </summary>
        /// <param name="graph">Data graph</param>
        /// <param name="generateAllEdges">Generate all available edges for graph</param>
        /// <param name="dataContextToDataItem">Sets visual edge and vertex controls DataContext property to vertex data item of the control (Allows prop binding in xaml templates)</param>
        public virtual Task GenerateGraphAsync(TGraph graph, bool generateAllEdges = true, bool dataContextToDataItem = true)
        {
            return GenerateGraphAsync(graph, CancellationToken.None, generateAllEdges, dataContextToDataItem);
        }

        public virtual Task GenerateGraphAsync(TGraph graph, CancellationToken cancellationToken, bool generateAllEdges = true, bool dataContextToDataItem = true)
        {
            if (LogicCore == null)
            {
                throw new GX_InvalidDataException("LogicCore -> Not initialized! (Is NULL)");
            }

            if (LogicCore.Graph == null)
            {
                throw new InvalidDataException("GraphArea.GenerateGraph() -> LogicCore.Graph property is null while trying to generate graph!");
            }

            LogicCore.PushFilters();
            if (AutoAssignMissingDataId)
            {
                AutoresolveIds(false, graph);
            }

            if (!LogicCore.IsCustomLayout)
            {
                PreloadVertexes(graph, dataContextToDataItem);
            }

            return _relayoutGraphMainAsync(cancellationToken, generateAllEdges, false);
        }

        /// <summary>
        /// Generate visual graph asynchronously using Graph property (it must be set before this method is called)
        /// </summary>
        /// <param name="generateAllEdges">Generate all available edges for graph</param>
        /// <param name="dataContextToDataItem">Sets visual edge and vertex controls DataContext property to vertex data item of the control (Allows prop binding in xaml templates)</param>
        public virtual Task GenerateGraphAsync(bool generateAllEdges = true, bool dataContextToDataItem = true)
        {
            return GenerateGraphAsync(LogicCore.Graph, generateAllEdges, dataContextToDataItem);
        }

        /// <summary>
        /// Returns all existing VertexControls added into the layout as new Array
        /// </summary>
        public override VertexControl[] GetAllVertexControls() { return _vertexlist.Values.ToArray(); }

        /// <summary>
        /// Returns all child controls of specified type using optional condition predicate
        /// </summary>
        /// <typeparam name="T">Type of the child</typeparam>
        public IEnumerable<T> GetChildControls<T>(Func<T, bool> condition = null)
        {
            return condition == null ? Children.OfType<T>() : Children.OfType<T>().Where(condition);
        }

        /// <summary>
        /// Gets logic core unsafely converted to specified type
        /// </summary>
        /// <typeparam name="T">Logic core type</typeparam>
        public T GetLogicCore<T>()
        {
            return (T)LogicCore;
        }

        /// <summary>
        /// Get controls related to specified control
        /// </summary>
        /// <param name="ctrl">Original control</param>
        /// <param name="resultType">Type of resulting related controls</param>
        /// <param name="edgesType">Optional edge controls type</param>
        public override List<IGraphControl> GetRelatedControls(IGraphControl ctrl, GraphControlType resultType = GraphControlType.VertexAndEdge, EdgesType edgesType = EdgesType.Out)
        {
            if (ctrl == null)
            {
                throw new GX_InvalidDataException("Supplied ctrl value is null!");
            }

            if (LogicCore == null)
            {
                throw new GX_InvalidDataException("LogicCore -> Not initialized!");
            }

            if (LogicCore.Graph == null)
            {
                Debug.WriteLine("LogicCore.Graph property not set while using GetRelatedControls method!");
                return null;
            }

            List<IGraphControl> list = new();
            if (ctrl is VertexControl vc)
            {
                //if (vc.Vertex == null) return null;
                List<TEdge> edgesInList = null;
                List<TEdge> edgesOutList = null;
                if (edgesType is EdgesType.In or EdgesType.All)
                {
                    LogicCore.Graph.TryGetInEdges(vc.Vertex as TVertex, out IEnumerable<TEdge> inEdges);
                    edgesInList = inEdges?.ToList();
                }

                if (edgesType is EdgesType.Out or EdgesType.All)
                {
                    LogicCore.Graph.TryGetOutEdges(vc.Vertex as TVertex, out IEnumerable<TEdge> outEdges);
                    edgesOutList = outEdges?.ToList();
                }

                if (resultType is GraphControlType.Edge or GraphControlType.VertexAndEdge)
                {
                    if (edgesInList != null)
                    {
                        list.AddRange(from item in edgesInList where _edgeslist.ContainsKey(item) select _edgeslist[item]);
                    }

                    if (edgesOutList != null)
                    {
                        list.AddRange(from item in edgesOutList where _edgeslist.ContainsKey(item) select _edgeslist[item]);
                    }
                }
                if (resultType != GraphControlType.Vertex && resultType != GraphControlType.VertexAndEdge)
                {
                    return list;
                }

                if (edgesInList != null)
                {
                    list.AddRange(from item in edgesInList where _vertexlist.ContainsKey(item.Source) select _vertexlist[item.Source]);
                }

                if (edgesOutList != null)
                {
                    list.AddRange(from item in edgesOutList where _vertexlist.ContainsKey(item.Target) select _vertexlist[item.Target]);
                }

                return list;
            }
            if (ctrl is not EdgeControl ec)
            {
                return list;
            }

            TEdge edge = (TEdge)ec.Edge;
            if (resultType == GraphControlType.Edge)
            {
                return list;
            }

            if (_vertexlist.ContainsKey(edge.Target))
            {
                list.Add(_vertexlist[edge.Target]);
            }

            if (_vertexlist.ContainsKey(edge.Source))
            {
                list.Add(_vertexlist[edge.Source]);
            }

            return list;
        }

        public override List<IGraphControl> GetRelatedEdgeControls(IGraphControl ctrl, EdgesType edgesType = EdgesType.All)
        {
            if (ctrl == null)
            {
                throw new GX_InvalidDataException("Supplied ctrl value is null!");
            }

            if (LogicCore == null)
            {
                throw new GX_InvalidDataException("LogicCore -> Not initialized!");
            }

            if (LogicCore.Graph == null)
            {
                Debug.WriteLine("LogicCore.Graph property not set while using GetRelatedEdgeControls method!");
                return null;
            }

            List<IGraphControl> list = new();
            if (ctrl is EdgeControl)
            {
                return list;
            }

            if (ctrl is VertexControl vc)
            {
                TVertex vData = vc.Vertex as TVertex;
                List<TEdge> eList = new();
                switch (edgesType)
                {
                    case EdgesType.All:
                        eList = LogicCore.Graph.GetAllEdges(vData).ToList();
                        break;

                    case EdgesType.In:
                        eList = LogicCore.Graph.GetInEdges(vData).ToList();
                        break;

                    case EdgesType.Out:
                        eList = LogicCore.Graph.GetOutEdges(vData).ToList();
                        break;
                }
                list.AddRange(EdgesList.Where(a => eList.Contains(a.Key)).Select(a => a.Value));
            }
            return list;
        }

        public override List<IGraphControl> GetRelatedVertexControls(IGraphControl ctrl, EdgesType edgesType = EdgesType.All)
        {
            if (ctrl == null)
            {
                throw new GX_InvalidDataException("Supplied ctrl value is null!");
            }

            if (LogicCore == null)
            {
                throw new GX_InvalidDataException("LogicCore -> Not initialized!");
            }

            if (LogicCore.Graph == null)
            {
                Debug.WriteLine("LogicCore.Graph property not set while using GetRelatedVertexControls method!");
                return null;
            }

            List<IGraphControl> list = new();
            if (ctrl is VertexControl vc)
            {
                TVertex vData = vc.Vertex as TVertex;
                List<TVertex> vList = new();
                switch (edgesType)
                {
                    case EdgesType.All:
                        vList = LogicCore.Graph.GetNeighbours(vData).ToList();
                        break;

                    case EdgesType.In:
                        vList = LogicCore.Graph.GetInNeighbours(vData).ToList();
                        break;

                    case EdgesType.Out:
                        vList = LogicCore.Graph.GetOutNeighbours(vData).ToList();
                        break;
                }
                list.AddRange(VertexList.Where(a => vList.Contains(a.Key)).Select(a => a.Value));
            }
            if (ctrl is not EdgeControl ec)
            {
                return list;
            }

            TEdge edge = (TEdge)ec.Edge;
            if (edge.Target != null && _vertexlist.ContainsKey(edge.Target))
            {
                list.Add(_vertexlist[edge.Target]);
            }
            if (edge.Source != null && _vertexlist.ContainsKey(edge.Source))
            {
                list.Add(_vertexlist[edge.Source]);
            }

            return list;
        }

        /// <summary>
        /// Returns first vertex that is found under specified coordinates
        /// </summary>
        /// <param name="position">GraphArea coordinate space position</param>
        public override VertexControl GetVertexControlAt(Point position)
        {
            Measure(new USize(double.PositiveInfinity, double.PositiveInfinity));

            return VertexList.Values.FirstOrDefault(a =>
            {
                Point pos = a.GetPosition();
                Rect rect = new Rect(pos.X, pos.Y, a.ActualWidth, a.ActualHeight);
                return rect.Contains(position.ToGraphX());
            });
        }

        /// <summary>
        /// Returns all vertices positions list
        /// </summary>
        public Dictionary<TVertex, Measure.Point> GetVertexPositions()
        {
            return VertexList.Where(a => ((IGraphXVertex)a.Value.Vertex).SkipProcessing != ProcessingOptionEnum.Exclude).ToDictionary(vertex => vertex.Key, vertex => vertex.Value.GetPositionGraphX());
        }

        /// <summary>
        /// Get vertex control sizes
        /// </summary>
        public Dictionary<TVertex, Size> GetVertexSizes()
        {
            //measure if needed and get all vertex sizes
            Measure(new USize(double.PositiveInfinity, double.PositiveInfinity));
            Dictionary<TVertex, Size> vertexSizes = new(_vertexlist.Count(a => ((IGraphXVertex)a.Value.Vertex).SkipProcessing != ProcessingOptionEnum.Exclude));
            //go through the vertex presenters and get the actual layoutpositions
            foreach (KeyValuePair<TVertex, VertexControl> vc in VertexList.Where(vc => ((IGraphXVertex)vc.Value.Vertex).SkipProcessing != ProcessingOptionEnum.Exclude))
            {
                vertexSizes[vc.Key] = new Size(vc.Value.DesiredSize.Width, vc.Value.DesiredSize.Height);
            }
            return vertexSizes;
        }

        public Dictionary<TVertex, Size> GetVertexSizesAndPositions(out IDictionary<TVertex, Measure.Point> vertexPositions)
        {
            //measure if needed and get all vertex sizes
            Measure(new USize(double.PositiveInfinity, double.PositiveInfinity));
            int count = _vertexlist.Count(a => ((IGraphXVertex)a.Value.Vertex).SkipProcessing != ProcessingOptionEnum.Exclude);
            Dictionary<TVertex, Size> vertexSizes = new(count);
            vertexPositions = new Dictionary<TVertex, Measure.Point>(count);
            //go through the vertex presenters and get the actual layoutpositions
            foreach (KeyValuePair<TVertex, VertexControl> vc in VertexList.Where(vc => ((IGraphXVertex)vc.Value.Vertex).SkipProcessing != ProcessingOptionEnum.Exclude))
            {
                vertexSizes[vc.Key] = new Size(vc.Value.DesiredSize.Width, vc.Value.DesiredSize.Height);
                vertexPositions[vc.Key] = vc.Value.GetPositionGraphX();
            }
            return vertexSizes;
        }

        /// <summary>
        /// Inserts custom control into GraphArea
        /// </summary>
        /// <param name="index">Insertion index</param>
        /// <param name="control">Custom control</param>
        public virtual void InsertCustomChildControl(int index, UIElement control)
        {
            Children.Insert(index, control);
            SetX(control, 0);
            SetY(control, 0);
        }

        /// <summary>
        /// Insert an edge to layout at specified position. By default, edge is inserted into the begining of the visual tree causing it to be rendered below all of the vertices.
        /// </summary>
        /// <param name="edgeData">Edge data object</param>
        /// <param name="edgeControl">Edge visual control</param>
        /// <param name="num">Insert position</param>
        /// <param name="generateLabel">Generate edge label for this control using EdgeLabelFactory</param>
        public void InsertEdge(TEdge edgeData, EdgeControl edgeControl, int num = 0, bool generateLabel = false)
        {
            if (AutoAssignMissingDataId && edgeData.ID == -1)
            {
                edgeData.ID = GetNextUniqueId(false);
            }

            InternalInsertEdge(edgeData, edgeControl, num);
            if (EnableVisualPropsApply && edgeControl != null)
            {
                ReapplySingleEdgeVisualProperties(edgeControl);
            }

            if (generateLabel && EdgeLabelFactory != null)
            {
                GenerateEdgeLabel(edgeControl);
            }
        }

        /// <summary>
        /// Usability extension method.
        /// Insert an edge to layout at specified position and add data edge. By default, edge is inserted into the begining of the visual tree causing it to be rendered below all of the vertices.
        /// LogicCore::Graph should be assigned or exception will be thrown.
        /// </summary>
        /// <param name="edgeData">Edge data object</param>
        /// <param name="edgeControl">Edge visual control</param>
        /// <param name="num">Insert position</param>
        /// <param name="generateLabel">Generate edge label for this control using EdgeLabelFactory</param>
        public void InsertEdgeAndData(TEdge edgeData, EdgeControl edgeControl, int num = 0, bool generateLabel = false)
        {
            if (LogicCore?.Graph == null)
            {
                throw new GX_InvalidDataException("LogicCore or its graph hasn't been assigned. Can't add data edge!");
            }

            LogicCore.Graph.AddEdge(edgeData);
            InsertEdge(edgeData, edgeControl, num, generateLabel);
        }

        /// <summary>
        /// Move specified visual entity to the bottom of the visual tree
        /// </summary>
        /// <param name="control">Visual entity</param>
        /// <param name="moveLabels">Also move attached labels (if any). Disable to decrease performance hit if you don't use labels.</param>
        public virtual void MoveToBack<T>(T control, bool moveLabels = true)
            where T : class
        {
            MoveTo(false, control, moveLabels);
        }

        /// <summary>
        /// Move specified visual entity on top of the visual tree
        /// </summary>
        /// <param name="control">Visual entity</param>
        /// <param name="moveLabels">Also move attached labels (if any)</param>
        public virtual void MoveToFront<T>(T control, bool moveLabels = true)
            where T : class
        {
            MoveTo(true, control, moveLabels);
        }

        /// <summary>
        /// For manual graph generation only!
        /// Generates visual objects for all vertices and edges w/o any algorithms. Objects are hidden by default. Optionaly, sets vertex coordinates.
        /// If there is any edge routing algorithm needed then it should be set before the call to this method.
        /// </summary>
        /// <param name="positions">Optional vertex positions</param>
        /// <param name="showObjectsIfPosSpecified">If True, all objects will be made visible when positions are specified</param>
        /// <param name="autoresolveIds">Automaticaly assign unique Ids to data objects. Can be vital for different GraphX logic parts such as parallel edges.</param>
        public virtual void PreloadGraph(Dictionary<TVertex, Point> positions = null, bool showObjectsIfPosSpecified = true, bool autoresolveIds = true)
        {
            if (LogicCore == null)
            {
                throw new GX_InvalidDataException("LogicCore -> Not initialized!");
            }

            if (LogicCore.Graph == null)
            {
                throw new GX_InvalidDataException("LogicCore.Graph -> Not initialized!");
            }

            if (autoresolveIds)
            {
                AutoresolveIds(false);
            }

            PreloadVertexes();

            if (positions != null)
            {
                foreach (KeyValuePair<TVertex, Point> item in positions)
                {
                    if (VertexList.ContainsKey(item.Key))
                    {
                        VertexList[item.Key].SetPosition(item.Value);
                    }

                    VertexList[item.Key].SetCurrentValue(PositioningCompleteProperty, true);
                }
            }
            UpdateLayout();
            RestoreAlgorithmStorage();
            GenerateAllEdges(positions != null ? Visibility.Visible : Visibility.Collapsed, false);
        }

        /// <summary>
        /// Clears all visual objects and generates VertexControl objects from specified graph. All vertices are created hidden by default.
        /// This method can be used for custom external algorithm implementations or manual visual graph population.
        /// </summary>
        /// <param name="graph">Data graph, by default is null and uses LogicCore.Graph as the source</param>
        /// <param name="dataContextToDataItem">Sets DataContext property to vertex data item of the control</param>
        /// <param name="forceVisPropRecovery"></param>
        public virtual void PreloadVertexes(TGraph graph = null, bool dataContextToDataItem = true, bool forceVisPropRecovery = false)
        {
            if (LogicCore == null)
            {
                throw new GX_InvalidDataException("LogicCore -> Not initialized!");
            }

            if (graph == null && LogicCore.Graph == null)
            {
                throw new GX_InvalidDataException("graph param empty and LogicCore.Graph -> Not initialized!");
            }

            graph ??= LogicCore.Graph;

            //clear edge and vertex controls
            RemoveAllVertices();
            RemoveAllEdges();

            //preload vertex controls
            foreach (TVertex it in graph.Vertices.Where(a => a.SkipProcessing != ProcessingOptionEnum.Exclude))
            {
                VertexControl vc = ControlFactory.CreateVertexControl(it);
                vc.DataContext = dataContextToDataItem ? it : null;
                vc.SetCurrentValue(PositioningCompleteProperty, false); // Style can make them invisible until positioning is complete (after layout positions are calculated)
                InternalAddVertex(it, vc);
            }

            GenerateVertexLabels();

            if (forceVisPropRecovery)
            {
                ReapplyVertexVisualProperties();
            }
            //assign graph
            LogicCore.Graph = graph;
        }

        /// <summary>
        /// Print current visual graph layout as visible in ZoomControl (if wrapped in)
        /// </summary>
        /// <param name="description">Optional header description</param>
        public virtual void PrintVisibleAreaDialog(string description = "")
        {
        }

        /// <summary>
        /// Rebuilds the graph layout from serialization data.
        /// </summary>
        /// <param name="data">The serialization data</param>
        /// <exception cref="GX_InvalidDataException">Occurs when LogicCore isn't set</exception>
        /// <exception cref="GX_SerializationException">Occurs when edge source or target isn't set</exception>
        public virtual void RebuildFromSerializationData(IEnumerable<GraphSerializationData> data)
        {
            if (LogicCore == null)
            {
                throw new GX_InvalidDataException("LogicCore -> Not initialized!");
            }

            RemoveAllEdges();
            RemoveAllVertices();

            if (LogicCore.Graph == null)
            {
                LogicCore.Graph = Activator.CreateInstance<TGraph>();
            }
            else
            {
                LogicCore.Graph.Clear();
            }

            IEnumerable<GraphSerializationData> vlist = data.Where(a => a.Data is TVertex);
            foreach (GraphSerializationData item in vlist)
            {
                TVertex vertexdata = item.Data as TVertex;
                VertexControl ctrl = ControlFactory.CreateVertexControl(vertexdata);
                ctrl.Visibility = item.IsVisible ? Visibility.Visible : Visibility.Collapsed;
                ctrl.SetPosition(item.Position.X, item.Position.Y);
                AddVertex(vertexdata, ctrl);
                LogicCore.Graph.AddVertex(vertexdata);
                ctrl.ApplyTemplate();
                if (item.HasLabel)
                {
                    GenerateVertexLabel(ctrl);
                }
            }
            IEnumerable<GraphSerializationData> elist = data.Where(a => a.Data is TEdge);

            foreach (GraphSerializationData item in elist)
            {
                if (item.Data is not TEdge edgedata)
                {
                    continue;
                }

                long sourceid = edgedata.Source.ID;
                long targetid = edgedata.Target.ID;
                TVertex datasource = _vertexlist.Keys.FirstOrDefault(a => a.ID == sourceid);
                TVertex datatarget = _vertexlist.Keys.FirstOrDefault(a => a.ID == targetid);

                edgedata.Source = datasource;
                edgedata.Target = datatarget;

                if (datasource == null || datatarget == null)
                {
                    throw new GX_SerializationException("DeserializeFromFile() -> Serialization logic is broken! Vertex not found. All vertices must be processed before edges!");
                }

                EdgeControl ecc = ControlFactory.CreateEdgeControl(_vertexlist[datasource], _vertexlist[datatarget], edgedata, true, item.IsVisible ? Visibility.Visible : Visibility.Collapsed);
                InsertEdge(edgedata, ecc);
                LogicCore.Graph.AddEdge(edgedata);
                if (item.HasLabel)
                {
                    GenerateEdgeLabel(ecc);
                }
            }

            if (AutoAssignMissingDataId)
            {
                AutoresolveIds(true);
            }

            //update edge layout and shapes manually
            //to correctly draw arrows in any case except they are manually disabled
            UpdateLayout();
            foreach (EdgeControl item in EdgesList.Values)
            {
                item.ApplyTemplate();
            }

            RestoreAlgorithmStorage();
        }

        public override Task RelayoutGraphAsync(bool generateAllEdges = false)
        {
            return RelayoutGraphAsync(CancellationToken.None, generateAllEdges);
        }

        /// <summary>
        /// Relayout graph using the same vertexes
        /// </summary>
        /// <param name="generateAllEdges">Generate all available edges for graph</param>
        public Task RelayoutGraphAsync(CancellationToken cancellationToken, bool generateAllEdges = false)
        {
            LogicCore.PushFilters();
            return _relayoutGraphMainAsync(cancellationToken, generateAllEdges, standalone: true);
        }

        /// <summary>
        /// Remove all edges from layout. Optionaly can remove edges from data graph also.
        /// </summary>
        /// <param name="removeEdgesFromDataGraph">Also remove edges from data graph if possible. Default value is False.</param>
        public void RemoveAllEdges(bool removeEdgesFromDataGraph = false)
        {
            bool hasStorage = LogicCore?.AlgorithmStorage != null;
            foreach (KeyValuePair<TEdge, EdgeControl> item in _edgeslist)
            {
                if (hasStorage && (item.Key.SkipProcessing != ProcessingOptionEnum.Exclude || removeEdgesFromDataGraph))
                {
                    LogicCore.AlgorithmStorage.RemoveSingleEdge(item.Key);
                }

                RemoveEdgeInternal(item.Key, false, removeEdgesFromDataGraph);
            }
            _edgeslist.Clear();
        }

        /// <summary>
        /// Remove all vertices from layout. Optionaly can remove vertices from data graph also.
        /// </summary>
        /// <param name="removeVerticesFromDataGraph">Also remove vertices from data graph if possible. Default value is False.</param>
        public void RemoveAllVertices(bool removeVerticesFromDataGraph = false)
        {
            bool hasStorage = LogicCore?.AlgorithmStorage != null;
            foreach (KeyValuePair<TVertex, VertexControl> item in _vertexlist)
            {
                RemoveVertexInternal(item.Key, false, removeVerticesFromDataGraph);
                if (hasStorage && (item.Key.SkipProcessing != ProcessingOptionEnum.Exclude || removeVerticesFromDataGraph))
                {
                    LogicCore.AlgorithmStorage.RemoveSingleVertex(item.Key);
                }
            }
            _vertexlist.Clear();
        }

        /// <summary>
        /// Remove custom control from GraphArea children.
        /// </summary>
        /// <param name="control">Custom control</param>
        public virtual void RemoveCustomChildControl(UIElement control)
        {
            Children.Remove(control);
        }

        /// <summary>
        /// Remove edge from layout
        /// </summary>
        /// <param name="edgeData">Edge data object</param>
        /// <param name="removeEdgeFromDataGraph">Remove edge from data graph if possible. Default value is False.</param>
        public void RemoveEdge(TEdge edgeData, bool removeEdgeFromDataGraph = false)
        {
            RemoveEdgeInternal(edgeData, true, removeEdgeFromDataGraph);
            bool hasStorage = LogicCore?.AlgorithmStorage != null && (edgeData.SkipProcessing != ProcessingOptionEnum.Exclude || removeEdgeFromDataGraph);
            if (hasStorage)
            {
                LogicCore.AlgorithmStorage.RemoveSingleEdge(edgeData);
            }
        }

        /// <summary>
        /// Remove vertex from layout
        /// </summary>
        /// <param name="vertexData">Vertex data object</param>
        /// <param name="removeVertexFromDataGraph">Also remove vertex from data graph if possible. Default value is False.</param>
        public void RemoveVertex(TVertex vertexData, bool removeVertexFromDataGraph = false)
        {
            RemoveVertexInternal(vertexData, true, removeVertexFromDataGraph);
            bool hasStorage = LogicCore?.AlgorithmStorage != null && (vertexData.SkipProcessing != ProcessingOptionEnum.Exclude || removeVertexFromDataGraph);
            if (hasStorage)
            {
                LogicCore.AlgorithmStorage.RemoveSingleVertex(vertexData);
            }
        }

        /// <summary>
        /// Remove vertex and all associated edges from the layout.
        /// </summary>
        /// <param name="vertexData">Vertex data object</param>
        /// <param name="eType">Edge types to remove</param>
        /// <param name="removeEdgesFromDataGraph">Also remove edges from data graph if possible. Default value is True.</param>
        /// <param name="removeVertexFromDataGraph">Also remove vertex from data graph if possible. Default value is True.</param>
        public void RemoveVertexAndEdges(TVertex vertexData, EdgesType eType = EdgesType.All, bool removeEdgesFromDataGraph = true, bool removeVertexFromDataGraph = true)
        {
            if (VertexList.ContainsKey(vertexData))
            {
                foreach (IGraphControl a in GetRelatedControls(VertexList[vertexData], GraphControlType.Edge, eType).ToList())
                {
                    RemoveEdge((TEdge)((EdgeControl)a).Edge, removeEdgesFromDataGraph);
                }
            }
            RemoveVertex(vertexData, removeVertexFromDataGraph);
        }

        /// <summary>
        /// Sets all edges dash style
        /// </summary>
        /// <param name="style">Selected style</param>
        public void SetEdgesDashStyle(EdgeDashStyle style)
        {
            _svEdgeDashStyle = style;
            foreach (KeyValuePair<TEdge, EdgeControl> item in EdgesList)
            {
                item.Value.DashStyle = style;
            }
        }

        /// <summary>
        /// Sets drag mode for all edges
        /// </summary>
        /// <param name="isEnabled">Is drag mode enabled</param>
        public void SetEdgesDrag(bool isEnabled)
        {
            _edgesDragEnabled = isEnabled;

            foreach (KeyValuePair<TEdge, EdgeControl> item in EdgesList)
            {
                DragBehaviour.SetIsDragEnabled(item.Value, isEnabled);
            }
        }

        /// <summary>
        /// Sets edges highlight logic
        /// </summary>
        /// <param name="isEnabled">Is highlight enabled</param>
        /// <param name="hlObjectsOfType">Highlight connected objects if specified type</param>
        public void SetEdgesHighlight(bool isEnabled, GraphControlType hlObjectsOfType)
        {
            _svEdgeHlEnabled = isEnabled;
            _svEdgeHlObjectType = hlObjectsOfType;

            foreach (KeyValuePair<TVertex, VertexControl> item in VertexList)
            {
                HighlightBehaviour.SetHighlighted(item.Value, false);
                HighlightBehaviour.SetIsHighlightEnabled(item.Value, isEnabled);
                HighlightBehaviour.SetHighlightControl(item.Value, hlObjectsOfType);
                HighlightBehaviour.SetHighlightEdges(item.Value, EdgesType.All);
            }
        }

        public void SetLogicCore(IGXLogicCore<TVertex, TEdge, TGraph> core)
        {
            LogicCore = core;
        }

        /// <summary>
        /// Sets GraphArea into printing mode when its size will be recalculated on each measuer and child controls will be arranged accordingly.
        /// Use with caution. Can spoil normal work while active but is essential to set before printing or grabbing an image.
        /// </summary>
        /// <param name="value">True or False</param>
        /// <param name="offsetControls">Offset child controls to fit into GraphArea control size</param>
        /// <param name="margin">Optional print area margin around the graph</param>
        public override void SetPrintMode(bool value, bool offsetControls = true, int margin = 0)
        {
        }

        /// <summary>
        /// Sets drag mode for all vertices
        /// </summary>
        /// <param name="isEnabled">Is drag mode enabled</param>
        /// <param name="updateEdgesOnMove">Is edges update enabled while dragging (use this if you have edge routing algorithms enabled)</param>
        public void SetVerticesDrag(bool isEnabled, bool updateEdgesOnMove = false)
        {
            _svVerticesDragEnabled = isEnabled;
            _svVerticesDragUpdateEdges = updateEdgesOnMove;

            foreach (KeyValuePair<TVertex, VertexControl> item in VertexList)
            {
                DragBehaviour.SetIsDragEnabled(item.Value, isEnabled);
                DragBehaviour.SetUpdateEdgesOnMove(item.Value, updateEdgesOnMove);
            }
        }

        /// <summary>
        /// Sets vertices highlight logic
        /// </summary>
        /// <param name="isEnabled">Is highlight enabled</param>
        /// <param name="hlObjectsOfType">Highlight connected objects if specified type</param>
        /// <param name="hlEdgesOfType">Highlight edges of specified type (according to previous property set)</param>
        public void SetVerticesHighlight(bool isEnabled, GraphControlType hlObjectsOfType, EdgesType hlEdgesOfType = EdgesType.All)
        {
            _svVertexHlEnabled = isEnabled;
            _svVertexHlObjectType = hlObjectsOfType;
            _svVertexHlEdgesType = hlEdgesOfType;
            foreach (KeyValuePair<TVertex, VertexControl> item in VertexList)
            {
                HighlightBehaviour.SetHighlighted(item.Value, false);
                HighlightBehaviour.SetIsHighlightEnabled(item.Value, isEnabled);
                HighlightBehaviour.SetHighlightControl(item.Value, hlObjectsOfType);
                HighlightBehaviour.SetHighlightEdges(item.Value, hlEdgesOfType);
            }
        }

        /// <summary>
        /// Sets math shape for all vertices
        /// </summary>
        /// <param name="shape">Selected math shape</param>
        public void SetVerticesMathShape(VertexShape shape)
        {
            _svVertexShape = shape;
            foreach (KeyValuePair<TVertex, VertexControl> item in VertexList)
            {
                item.Value.SetCurrentValue(VertexControlBase.VertexShapeProperty, shape);
            }
        }

        // EdgeDashStyle.Solid;
        /// <summary>
        /// Show or hide all edges arrows. Default value is True.
        /// </summary>
        /// <param name="isEnabled">Boolean value</param>
        public void ShowAllEdgesArrows(bool isEnabled = true)
        {
            _svShowEdgeArrows = isEnabled;
            foreach (EdgeControl item in _edgeslist.Values)
            {
                item.SetCurrentValue(EdgeControlBase.ShowArrowsProperty, isEnabled);
            }
        }

        //private bool? _svShowEdgeLabels;
        /// <summary>
        /// Show or hide all edges labels
        /// </summary>
        /// <param name="isEnabled">Boolean value</param>
        public void ShowAllEdgesLabels(bool isEnabled = true)
        {
            //_svShowEdgeLabels = isEnabled;
            foreach (EdgeControl item in _edgeslist.Values)
            {
                foreach (FrameworkElement l in item.EdgeLabelControls.Cast<FrameworkElement>())
                {
                    l.SetCurrentValue(EdgeLabelControl.ShowLabelProperty, isEnabled);
                }
            }
        }

        /// <summary>
        /// Show or hide all vertex labels
        /// </summary>
        /// <param name="isEnabled">Boolean value</param>
        public void ShowAllVerticesLabels(bool isEnabled = true)
        {
            _svVertexLabelShow = isEnabled;
            foreach (VertexControl item in _vertexlist.Values)
            {
                item.SetCurrentValue(VertexControlBase.ShowLabelProperty, isEnabled);
            }
        }

        /// <summary>
        /// Update visual appearance for all possible visual edges
        /// </summary>
        /// <param name="performFullUpdate">If True - perform full edge update including all children checks such as pointers & labels. If False - update only edge routing and edge visual</param>
        public virtual void UpdateAllEdges(bool performFullUpdate = false)
        {
            if (LogicCore == null)
            {
                throw new GX_InvalidDataException("LogicCore -> Not initialized!");
            }

            if (LogicCore.EnableParallelEdges)
            {
                UpdateParallelEdgesData();
            }

            foreach (EdgeControl ec in _edgeslist.Values)
            {
                if (!performFullUpdate)
                {
                    ec.UpdateEdgeRendering();
                }
                else
                {
                    ec.UpdateEdge();
                }
            }
        }

        public void UpdateEdgeLabelPosition(bool value)
        {
            _svUpdateLabelPosition = value;
            foreach (KeyValuePair<TEdge, EdgeControl> item in EdgesList)
            {
                item.Value.UpdateLabelPosition = value;
            }
        }

        /// <summary>
        /// Update parallel edges information. Only needed to be run when edges has been added manualy and has to track parallel ones.
        /// Essentialy refreshes EdgeControl::IsParallel property
        /// </summary>
        /// <param name="edgeList">Optonal parameter. Specifies initial list of edges. If null then all edges are parsed. Default value is Null.</param>
        public virtual void UpdateParallelEdgesData(Dictionary<TEdge, EdgeControl> edgeList = null)
        {
            edgeList ??= _edgeslist;

            //clear IsParallel flag
            foreach (EdgeControl ec in edgeList.Values)
            {
                ec.IsParallel = false;
            }

            // Group edges together that share the same source and target. Edges that have both a source and target connection point defined are excluded. Self
            // looped edges are excluded. Edges marked with CanBeParallel == false are excluded. Edges with a connection point are pushed to the end of the group
            // and will be marked as parallel, but their offsets end up overridden during rendering.
            List<List<KeyValuePair<TEdge, EdgeControl>>> edgeGroups =
                (from edge in edgeList
                 where edge.Value.CanBeParallel && !edge.Key.IsSelfLoop && (!edge.Key.SourceConnectionPointId.HasValue || !edge.Key.TargetConnectionPointId.HasValue)
                 group edge by new Tuple<long, long>(Math.Min(edge.Key.Source.ID, edge.Key.Target.ID), Math.Max(edge.Key.Source.ID, edge.Key.Target.ID)) into edgeGroup
                 select edgeGroup.OrderBy(e => e.Key.SourceConnectionPointId.HasValue || e.Key.TargetConnectionPointId.HasValue ? 1 : 0).ToList())
                .ToList();

            foreach (List<KeyValuePair<TEdge, EdgeControl>> list in edgeGroups)
            {
                KeyValuePair<TEdge, EdgeControl> first = list[0];

                // Alternate sides with each step
                int viceversa = 1;
                // Check if total number of edges without connection points is even or not
                bool even = (list.TakeWhile(e => !e.Key.SourceConnectionPointId.HasValue && !e.Key.TargetConnectionPointId.HasValue).Count() % 2) == 0;
                // For even numbers of edges, initial offset is a half step from the center
                int initialOffset = even ? LogicCore.ParallelEdgeDistance / 2 : 0;

                for (int i = 0; i < list.Count; i++)
                {
                    KeyValuePair<TEdge, EdgeControl> kvp = list[i];
                    kvp.Value.IsParallel = true;

                    int offset = viceversa * (initialOffset + LogicCore.ParallelEdgeDistance * ((i + (even ? 0 : 1)) / 2));
                    //if source to target edge
                    if (kvp.Key.Source == first.Key.Source)
                    {
                        kvp.Value.ParallelEdgeOffset = offset;
                    }
                    else //if target to source edge - just switch offsets
                    {
                        kvp.Value.ParallelEdgeOffset = -offset;
                    }
                    //change trigger to opposite
                    viceversa = -viceversa;
                }
            }
        }

        // = VertexShape.Rectangle;
        // = GraphControlType.VertexAndEdge;
        // = EdgesType.All;
        // = GraphControlType.VertexAndEdge;
        /// <summary>
        /// Compute new edge routes for all edges of the vertex
        /// </summary>
        /// <param name="vc">Vertex visual control</param>
        /// <param name="vertexDataNeedUpdate">If vertex data inside edge routing algorthm needs to be updated</param>
        internal override void ComputeEdgeRoutesByVertex(VertexControl vc, bool vertexDataNeedUpdate = true)
        {
            if (LogicCore == null)
            {
                throw new GX_InvalidDataException("LogicCore is not initialized!");
            }

            LogicCore.ComputeEdgeRoutesByVertex((TVertex)vc.Vertex, vertexDataNeedUpdate ? (Measure.Point?)vc.GetPositionGraphX() : null, vertexDataNeedUpdate ? (Size?)new Size(vc.ActualWidth, vc.ActualHeight) : null);
        }

        protected virtual async Task _relayoutGraphMainAsync(CancellationToken externalCancellationToken, bool generateAllEdges = false, bool standalone = true)
        {
            if (LogicCore == null)
            {
                throw new GX_InvalidDataException("LogicCore -> Not initialized!");
            }

            await CancelRelayoutAsync();

            _layoutCancellationSource = new CancellationTokenSource();

            if (externalCancellationToken != CancellationToken.None)
            {
                _linkedLayoutCancellationSource = CancellationTokenSource.CreateLinkedTokenSource(_layoutCancellationSource.Token, externalCancellationToken);
            }

            _layoutTask = RelayoutGraph((_linkedLayoutCancellationSource ?? _layoutCancellationSource).Token, generateAllEdges, standalone);
            await _layoutTask;
        }

        protected virtual void AutoresolveEdgeIds(TGraph graph = null)
        {
            if (LogicCore == null)
            {
                throw new GX_InvalidDataException("LogicCore -> Not initialized!");
            }

            if (graph == null)
            {
                graph = LogicCore.Graph;
            }

            if (graph == null)
            {
                return;
            }

            EdgeDataIdsCollection.Clear();
            _edgeDataIdCounter = 1;
            foreach (TEdge item in graph.Edges.Where(a => a.ID != -1))
            {
                bool added = EdgeDataIdsCollection.Add(item.ID);
                Debug.Assert(added,
                    $"Duplicate ID '{item.ID}' found while adding an edge ID during rebuild of data ID collection.");
            }
            foreach (TEdge item in graph.Edges.Where(a => a.ID == -1))
            {
                item.ID = GetNextUniqueId(false);
            }
        }

        protected virtual void AutoresolveIds(bool includeEdgeIds, TGraph graph = null)
        {
            if (LogicCore == null)
            {
                throw new GX_InvalidDataException("LogicCore -> Not initialized!");
            }

            if (graph == null)
            {
                graph = LogicCore.Graph;
            }

            if (graph == null)
            {
                return;
            }

            DataIdsCollection.Clear();
            _dataIdCounter = 1;

            // First, rebuild data ID collection for all vertices and edges that already have assigned IDs.
            foreach (TVertex item in graph.Vertices.Where(a => a.ID != -1))
            {
                bool added = DataIdsCollection.Add(item.ID);
                Debug.Assert(added,
                    $"Duplicate ID '{item.ID}' found while adding a vertex ID during rebuild of data ID collection.");
            }

            // Generate unique IDs for all vertices and edges that don't already have a unique ID.
            foreach (TVertex item in graph.Vertices.Where(a => a.ID == -1))
            {
                item.ID = GetNextUniqueId(true);
            }

            if (includeEdgeIds)
            {
                AutoresolveEdgeIds(graph);
            }
        }

        protected virtual void CreateNewStateStorage()
        {
            _stateStorage = new StateStorage<TVertex, TEdge, TGraph>(this);
        }

        protected virtual void CustomReapplySingleEdgeVisualProperties(EdgeControl item)
        {
        }

        protected virtual void CustomReapplySingleVertexVisualProperties(VertexControl item)
        {
        }

        protected virtual void GenerateAllEdgesInternal(Visibility defaultVisibility = Visibility.Visible)
        {
            if (LogicCore == null)
            {
                throw new GX_InvalidDataException("LogicCore -> Not initialized!");
            }

            RemoveAllEdges();

            AutoresolveEdgeIds();

            foreach (TEdge item in LogicCore.Graph.Edges)
            {
                if (item.Source == null || item.Target == null)
                {
                    continue;
                }

                if (!_vertexlist.ContainsKey(item.Source) || !_vertexlist.ContainsKey(item.Target))
                {
                    continue;
                }

                EdgeControl edgectrl = ControlFactory.CreateEdgeControl(
                    _vertexlist[item.Source],
                    _vertexlist[item.Target],
                    item,
                    _svShowEdgeArrows ?? true,
                    defaultVisibility);

                InternalInsertEdge(item, edgectrl);
                //setup path
            }

            if (LogicCore.EnableParallelEdges)
            {
                UpdateParallelEdgesData();
            }

            foreach (KeyValuePair<TEdge, EdgeControl> item in _edgeslist)
            {
                item.Value.PrepareEdgePath();
            }

            GenerateEdgeLabels();
        }

        protected virtual void GenerateEdgeLabel(EdgeControl edgeControl)
        {
            IEnumerable<UIElement> labels = EdgeLabelFactory.CreateLabel(edgeControl);
            if (labels == null)
            {
                return;
            }

            if (labels.Any(a => a is not IEdgeLabelControl))
            {
                throw new GX_InvalidDataException("Generated edge label should implement IEdgeLabelControl interface");
            }

            foreach (UIElement l in labels)
            {
                AddCustomChildControl(l);
                l.Measure(new USize(double.MaxValue, double.MaxValue));
                ((IEdgeLabelControl)l).UpdatePosition();
            }
        }

        protected virtual void GenerateEdgeLabels()
        {
            if (EdgeLabelFactory == null)
            {
                return;
            }

            List<UIElement> list = Children.OfType<IEdgeLabelControl>()
                .Cast<UIElement>()
                .ToList();

            foreach (UIElement a in list)
            {
                Children.Remove(a);
            }
            foreach (EdgeControl ec in EdgesList.Values)
            {
                GenerateEdgeLabel(ec);
            }
        }

        protected virtual void GenerateVertexLabel(VertexControl vertexControl)
        {
            IEnumerable<UIElement> labels = VertexLabelFactory.CreateLabel(vertexControl);
            if (labels == null)
            {
                return;
            }

            if (labels.Any(l => l is not IVertexLabelControl))
            {
                throw new GX_InvalidDataException("Generated vertex label should implement IVertexLabelControl interface");
            }

            foreach (UIElement l in labels)
            {
                if (_svVertexLabelShow == false || vertexControl.Visibility != Visibility.Visible)
                {
                    l.Visibility = Visibility.Collapsed;
                }

                AddCustomChildControl(l);
                l.Measure(new USize(double.MaxValue, double.MaxValue));
                ((IVertexLabelControl)l).UpdatePosition();
            }
        }

        protected virtual void GenerateVertexLabels()
        {
            if (VertexLabelFactory == null)
            {
                return;
            }

            List<UIElement> list = Children.OfType<IVertexLabelControl>()
                .Cast<UIElement>()
                .ToList();

            foreach (UIElement a in list)
            {
                Children.Remove(a);
            }
            foreach (VertexControl vc in VertexList.Values)
            {
                GenerateVertexLabel(vc);
            }
        }

        protected virtual int GetNextUniqueId(bool isVertex)
        {
            if (isVertex)
            {
                while (DataIdsCollection.Contains(_dataIdCounter))
                {
                    _dataIdCounter++;
                }
                DataIdsCollection.Add(_dataIdCounter);
                return _dataIdCounter;
            }
            while (EdgeDataIdsCollection.Contains(_edgeDataIdCounter))
            {
                _edgeDataIdCounter++;
            }
            EdgeDataIdsCollection.Add(_edgeDataIdCounter);
            return _edgeDataIdCounter;
        }

        protected void InternalAddEdge(TEdge edgeData, EdgeControl edgeControl)
        {
            if (edgeControl == null || edgeData == null)
            {
                return;
            }

            if (_edgeslist.ContainsKey(edgeData))
            {
                throw new GX_InvalidDataException("AddEdge() -> An edge with the same data has already been added to layout!");
            }

            edgeControl.RootArea = this;
            _edgeslist.Add(edgeData, edgeControl);
            Children.Add(edgeControl);
        }

        protected void InternalAddVertex(TVertex vertexData, VertexControl vertexControl)
        {
            if (vertexControl == null || vertexData == null)
            {
                return;
            }

            vertexControl.RootArea = this;
            if (_vertexlist.ContainsKey(vertexData))
            {
                throw new GX_InvalidDataException("AddVertex() -> Vertex with the same data has already been added to layout!");
            }

            _vertexlist.Add(vertexData, vertexControl);
            Children.Add(vertexControl);
        }

        protected void InternalInsertEdge(TEdge edgeData, EdgeControl edgeControl, int num = 0)
        {
            if (edgeControl == null || edgeData == null)
            {
                return;
            }

            if (_edgeslist.ContainsKey(edgeData))
            {
                throw new GX_InvalidDataException("AddEdge() -> An edge with the same data has already been added!");
            }

            edgeControl.RootArea = this;
            _edgeslist.Add(edgeData, edgeControl);
            try
            {
                if (ControlsDrawOrder == ControlDrawOrder.VerticesOnTop || num != 0)
                {
                    Children.Insert(num, edgeControl);
                }
                else
                {
                    Children.Add(edgeControl);
                }
            }
            catch (Exception ex)
            {
                throw new GX_GeneralException(ex.Message + ". Probably you have an error in edge template.", ex);
            }
        }

        /// <summary>
        /// Internal method to process MoveTo public methods
        /// </summary>
        /// <typeparam name="T">Control type</typeparam>
        /// <param name="toFront">If True - move to front overwise move to back</param>
        /// <param name="control">Control</param>
        /// <param name="moveLabels">Also move labels</param>
        protected virtual void MoveTo<T>(bool toFront, T control, bool moveLabels = true)
            where T : class
        {
            UIElement result = (UIElement)(object)Children.OfType<T>().FirstOrDefault(a => a == control);
            if (result == null)
            {
                return;
            }

            if (!Children.Contains(result))
            {
                return;
            }

            Children.Remove(result);
            if (toFront)
            {
                Children.Add(result);
            }
            else
            {
                Children.Insert(0, result);
            }

            if (moveLabels)
            {
                VertexControl vResult = result as VertexControl;
                EdgeControl eResult = result as EdgeControl;
                UIElement element = null;
                if (vResult?.VertexLabelControl != null)
                {
                    element = (UIElement)vResult.VertexLabelControl;
                }

                if (eResult?.EdgeLabelControls.Count > 0)
                {
                    foreach (IEdgeLabelControl l in eResult.EdgeLabelControls)
                    {
                        if (Children.Contains((UIElement)l))
                        {
                            Children.Remove((UIElement)l);
                            if (toFront)
                            {
                                Children.Add((UIElement)l);
                            }
                            else
                            {
                                Children.Insert(0, (UIElement)l);
                            }
                        }
                    }
                }
                else if (element != null && Children.Contains(element))
                {
                    Children.Remove(element);
                    if (toFront)
                    {
                        Children.Add(element);
                    }
                    else
                    {
                        Children.Insert(0, element);
                    }
                }
            }
        }

        /// <summary>
        /// Runs when base dispose is done
        /// </summary>
        protected virtual void OnDispose() { }

        protected void ReapplyEdgeVisualProperties()
        {
            foreach (EdgeControl item in EdgesList.Values)
            {
                ReapplySingleEdgeVisualProperties(item);
            }
        }

        protected void ReapplySingleEdgeVisualProperties(EdgeControl item)
        {
            if (_edgesDragEnabled != null)
            {
                DragBehaviour.SetIsDragEnabled(item, _edgesDragEnabled.Value);
            }

            if (_svEdgeDashStyle != null)
            {
                item.DashStyle = _svEdgeDashStyle.Value;
            }

            if (_svShowEdgeArrows != null)
            {
                item.SetCurrentValue(EdgeControlBase.ShowArrowsProperty, _svShowEdgeArrows.Value);
            }
            //if (_svShowEdgeLabels != null) item.ShowLabel = _svShowEdgeLabels.Value;
            //if (_svAlignEdgeLabels != null) item.AlignLabelsToEdges = _svAlignEdgeLabels.Value;
            if (_svUpdateLabelPosition != null)
            {
                item.UpdateLabelPosition = _svUpdateLabelPosition.Value;
            }

            if (_svEdgeHlEnabled != null)
            {
                HighlightBehaviour.SetIsHighlightEnabled(item, _svEdgeHlEnabled.Value);
            }

            if (_svEdgeHlObjectType != null)
            {
                HighlightBehaviour.SetHighlightControl(item, _svEdgeHlObjectType.Value);
            }

            HighlightBehaviour.SetHighlightEdges(item, EdgesType.All);
            CustomReapplySingleEdgeVisualProperties(item);
        }

        protected void ReapplySingleVertexVisualProperties(VertexControl item)
        {
            if (_svVerticesDragEnabled != null)
            {
                DragBehaviour.SetIsDragEnabled(item, _svVerticesDragEnabled.Value);
            }

            if (_svVerticesDragUpdateEdges != null)
            {
                DragBehaviour.SetUpdateEdgesOnMove(item, _svVerticesDragUpdateEdges.Value);
            }

            if (_svVertexShape != null)
            {
                item.VertexShape = _svVertexShape.Value;
            }

            if (_svVertexLabelShow != null)
            {
                item.ShowLabel = _svVertexLabelShow.Value;
            }

            if (_svVertexHlEnabled != null)
            {
                HighlightBehaviour.SetIsHighlightEnabled(item, _svVertexHlEnabled.Value);
            }

            if (_svVertexHlObjectType != null)
            {
                HighlightBehaviour.SetHighlightControl(item, _svVertexHlObjectType.Value);
            }

            if (_svVertexHlEdgesType != null)
            {
                HighlightBehaviour.SetHighlightEdges(item, _svVertexHlEdgesType.Value);
            }

            CustomReapplySingleVertexVisualProperties(item);
        }

        protected void ReapplyVertexVisualProperties()
        {
            foreach (VertexControl item in VertexList.Values)
            {
                ReapplySingleVertexVisualProperties(item);
            }
        }

        protected virtual Task RelayoutGraph(CancellationToken cancellationToken, bool generateAllEdges = false, bool standalone = true)
        {
            return Task.Run(async () =>
            {
                Dictionary<TVertex, Size> vertexSizes = null;
                IDictionary<TVertex, Measure.Point> vertexPositions = null;
                IGXLogicCore<TVertex, TEdge, TGraph> localLogicCore = null;

                await DispatcherHelper.CheckBeginInvokeOnUi(() =>
                {
                    if (LogicCore == null)
                    {
                        return;
                    }

                    //add missing visuals and remove old ones if graph is filtered to reflect filtering
                    if (EnableVisualsRenewOnFiltering && (LogicCore.IsFiltered || LogicCore.IsFilterRemoved))
                    {
                        //remove edge if it has been removed from data graph
                        foreach (TEdge e in _edgeslist.Keys.ToList())
                        {
                            if (!LogicCore.Graph.Edges.Contains(e))
                            {
                                RemoveEdge(e);
                            }
                        }
                        //remove vertex if it has been removed from data graph
                        foreach (TVertex v in _vertexlist.Keys.ToList())
                        {
                            if (!LogicCore.Graph.Vertices.Contains(v))
                            {
                                RemoveVertex(v);
                            }
                        }

                        foreach (TVertex v in LogicCore.Graph.Vertices)
                        {
                            if (!_vertexlist.ContainsKey(v))
                            {
                                AddVertex(v, ControlFactory.CreateVertexControl(v));
                            }
                        }

                        foreach (TEdge e in LogicCore.Graph.Edges)
                        {
                            if (!_edgeslist.ContainsKey(e))
                            {
                                VertexControl source = _vertexlist[e.Source];
                                VertexControl target = _vertexlist[e.Target];
                                AddEdge(e, ControlFactory.CreateEdgeControl(source, target, e));
                            }
                        }
                    }

                    UpdateLayout(); //update layout so we can get actual control sizes

                    if (LogicCore.AreVertexSizesNeeded())
                    {
                        vertexSizes = GetVertexSizesAndPositions(out vertexPositions);
                    }
                    else
                    {
                        vertexPositions = GetVertexPositions();
                    }

                    //TODO may be wrong. Fix for vertexControl pos not NaN by default as in WPF
                    //So if all coordinates are zeroes then it is initial run - clear them
                    if (vertexPositions.All(a => a.Value == GraphX.Measure.Point.Zero))
                    {
                        vertexPositions.Clear();
                    }

                    localLogicCore = LogicCore;
                });

                if (localLogicCore == null)
                {
                    throw new GX_InvalidDataException("LogicCore -> Not initialized!");
                }

                if (!localLogicCore.GenerateAlgorithmStorage(vertexSizes, vertexPositions))
                {
                    return;
                }

                //clear routing info
                foreach (TEdge a in localLogicCore.Graph.Edges)
                {
                    a.RoutingPoints = null;
                }

                IDictionary<TVertex, Measure.Point> resultCoords = localLogicCore.Compute(cancellationToken);
                DateTime t = DateTime.Now;
                await DispatcherHelper.CheckBeginInvokeOnUi(() =>
                {
                    if (MoveAnimation != null)
                    {
                        MoveAnimation.CleanupBaseData();
                        MoveAnimation.Cleanup();
                    }
                    //setup vertex positions from result data
                    foreach (KeyValuePair<TVertex, Measure.Point> item in resultCoords)
                    {
                        if (!_vertexlist.ContainsKey(item.Key))
                        {
                            continue;
                        }

                        VertexControl vc = _vertexlist[item.Key];

                        SetFinalX(vc, item.Value.X);
                        SetFinalY(vc, item.Value.Y);

                        if (MoveAnimation == null || double.IsNaN(GetX(vc)))
                        {
                            vc.SetPosition(item.Value.X, item.Value.Y, false);
                        }
                        else
                        {
                            MoveAnimation.AddVertexData(vc, item.Value);
                        }

                        vc.SetCurrentValue(PositioningCompleteProperty, true); // Style can show vertexes with layout positions assigned
                    }
                    if (MoveAnimation != null)
                    {
                        if (MoveAnimation.VertexStorage.Count > 0)
                        {
                            MoveAnimation.RunVertexAnimation();
                        }

                        foreach (EdgeControl item in _edgeslist.Values)
                        {
                            MoveAnimation.AddEdgeData(item);
                        }

                        if (MoveAnimation.EdgeStorage.Count > 0)
                        {
                            MoveAnimation.RunEdgeAnimation();
                        }
                    }

                    MeasureOverride(new Windows.Foundation.Size(double.PositiveInfinity, double.PositiveInfinity));

                    if (generateAllEdges)
                    {
                        if (_edgeslist.Count == 0)
                        {
                            GenerateAllEdgesInternal();
                            if (EnableVisualPropsRecovery)
                            {
                                ReapplyEdgeVisualProperties();
                            }
                        }
                        else
                        {
                            UpdateAllEdges();
                        }
                    }
                    if (!standalone)
                    {
                        if (EnableVisualPropsRecovery)
                        {
                            ReapplyVertexVisualProperties();
                        }

                        OnGenerateGraphFinished();
                    }
                    else
                    {
                        OnRelayoutFinished();
                    }
                });
            }, cancellationToken);
        }

        /// <summary>
        /// Deletes vertices and edges correctly after delete animation
        /// </summary>
        /// <param name="ctrl">Control</param>
        /// <param name="removeDataObject">Remove data object if possible</param>
        protected override void RemoveAnimatedControl(IGraphControl ctrl, bool removeDataObject)
        {
            if (ctrl is VertexControl control)
            {
                RemoveVertexInternal(control, removeDataObject);
                return;
            }
            if (ctrl is EdgeControl edgeControl)
            {
                RemoveEdgeInternal(edgeControl, removeDataObject);
            }
        }

        /// <summary>
        /// Dummy property. Use EdgesList and VertexList instead.
        /// Also use corresponding methods to modify item collections.
        /// </summary>
        //private new UIElementCollection Children { get { return null; } }
        private static async void Logic_core_changed(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            GraphArea<TVertex, TEdge, TGraph> graph = d as GraphArea<TVertex, TEdge, TGraph>;
            if (graph?.Parent == null)
            {
                return;
            }

            switch (graph.LogicCoreChangeAction)
            {
                case LogicCoreChangedAction.GenerateGraph:
                    await graph.GenerateGraphAsync();
                    break;

                case LogicCoreChangedAction.GenerateGraphWithEdges:
                    await graph.GenerateGraphAsync(true);
                    break;

                case LogicCoreChangedAction.RelayoutGraph:
                    await graph.RelayoutGraphAsync();
                    break;

                case LogicCoreChangedAction.RelayoutGraphWithEdges:
                    await graph.RelayoutGraphAsync(true);
                    break;

                default:
                    break;
            }
        }

        private void RemoveEdgeInternal(TEdge edgeData, bool removeFromList, bool removeEdgeFromDataGraph = false)
        {
            if (edgeData == null || !_edgeslist.ContainsKey(edgeData))
            {
                return;
            }

            EdgeControl ctrl = _edgeslist[edgeData];
            if (removeFromList)
            {
                _edgeslist.Remove(edgeData);
            }

            if (DeleteAnimation != null)
            {
                DeleteAnimation.AnimateEdge(ctrl);
            }
            else
            {
                RemoveEdgeInternal(ctrl, removeEdgeFromDataGraph);
            }
        }

        private void RemoveEdgeInternal(EdgeControlBase ctrl, bool removeEdgeFromDataGraph = false)
        {
            ctrl.DetachLabels();

            Children.Remove(ctrl);
            if (removeEdgeFromDataGraph && LogicCore?.Graph != null && LogicCore.Graph.ContainsEdge(ctrl.Edge as TEdge))
            {
                LogicCore.Graph.RemoveEdge(ctrl.Edge as TEdge);
            }

            ctrl.Clean();
        }

        private void RemoveVertexInternal(TVertex vertexData, bool removeFromList, bool removeVertexFromDataGraph = false)
        {
            if (vertexData == null || !_vertexlist.ContainsKey(vertexData))
            {
                return;
            }

            VertexControl ctrl = _vertexlist[vertexData];
            if (removeFromList)
            {
                _vertexlist.Remove(vertexData);
            }

            if (DeleteAnimation != null)
            {
                DeleteAnimation.AnimateVertex(ctrl);
            }
            else
            {
                RemoveVertexInternal(ctrl, removeVertexFromDataGraph);
            }
        }

        private void RemoveVertexInternal(VertexControl ctrl, bool removeVertexFromDataGraph = false)
        {
            if (ctrl.VertexLabelControl != null)
            {
                Children.Remove((UIElement)ctrl.VertexLabelControl);
                ctrl.DetachLabel();
            }
            Children.Remove(ctrl);
            if (removeVertexFromDataGraph && LogicCore?.Graph != null && LogicCore.Graph.ContainsVertex(ctrl.Vertex as TVertex))
            {
                LogicCore.Graph.RemoveVertex(ctrl.Vertex as TVertex);
            }

            ctrl.Clean();
        }

        private void RestoreAlgorithmStorage()
        {
            Dictionary<TVertex, Size> vSizes = GetVertexSizesAndPositions(out IDictionary<TVertex, Measure.Point> vPositions);
            LogicCore.GenerateAlgorithmStorage(vSizes, vPositions);
        }
    }
}